#!/usr/bin/env bash
# set -x

source arg_parse.sh

# ================================================================================================
#                                            SETTINGS
debug_mode=0
dockerfile="Dockerfile.default"
JOBS=$(nproc --all)
container_id=
force=0
attach=0
persist=0
auto_select=0
image_tag="dev"
extra_args=()

# ================================================================================================
#                                            GLOBALS
DEPENDENCIES=("tput" "cam" "lsusb" "docker" "buildg")

created_container=
selected_item_index=

# ================================================================================================
#                                             TASKS
# (1: message to print)
function debug () {
    [[ ${debug_mode} -eq 1 ]] && echo $1
}

function init () {
    source .env
    export DOCKER_BUILDKIT=1
}

function cleanup () {
    [[ ${created_container} -eq 1 && ${persist} -eq 0 ]] && docker rm -v ${container_id} 2>&1 >/dev/null
}

function validate_dependencies () {
    return
}


# sets variables `cam_output`, `ids`, `lsusb_output`, `bus_ids`, `bus_addrs`, `usb_list` for use elsewhere
function usb_init () {
    # Store video devices using libcamera
    cam_output=$(cam -l 2>/dev/null)

    # Find device entries like "UVC Camera (046d:0825) (usb-0000:00:14.0-3)"
    ids=$(echo "${cam_output}" | grep -oE '[0-9a-f]{4}:[0-9a-f]{4}' | uniq)
    ids=$(echo -n "${ids}" | tr "\n" "|")

    # highlight the device IDs in pink
    cam_output=$(echo "${cam_output}" | sed -E "s@(${ids})@\o033[45;30m&\o033[0m@g")

    # Store usb devices using usbutils
    lsusb_output=$(lsusb)

    bus_ids=$(echo "${lsusb_output}" | sed -En "s/Bus ([0-9]{3}) Device ([0-9]{3}): ID (${ids}).*/\1/p" | awk '{ printf "%d,", $1 }' | head -c -1)
    bus_addrs=$(echo "${lsusb_output}" | sed -En "s/Bus ([0-9]{3}) Device ([0-9]{3}): ID (${ids}).*/\2/p" | awk '{ printf "%d,", $1 }' | head -c -1)

    lsusb_output=$(echo "${lsusb_output}" | sed -E "s/Bus ([0-9]{3}) Device ([0-9]{3}): ID (${ids})/Bus \x1b[46;30m\1\x1b[0m Device \x1b[42;30m\2\x1b[0m: ID \3/g")

    # Split variables into arrays based on comma (,)
    IFS=',' read -ra id_list <<< "${bus_ids}"
    IFS=',' read -ra addr_list <<< "${bus_addrs}"

    usb_list=()
    for ((i=0; i<${#id_list[@]}; i++)); do
        # Find the ID from the match
        local addition=(${id_list[$i]},${addr_list[$i]})
        usb_list+=(${addition})
    done
}

function validate_usb_devices () {
    for ((i=0; i<${#id_list[@]}; i++)); do
        local id=$(printf "%0.3i" ${id_list[$i]})
        local addr=$(printf "%0.3i" ${addr_list[$i]})
        local device="/dev/bus/usb/${id}/${addr}"

        # TODO: Check why this works on some systems and not others
        # Check permissions for the device
        if [[ ! -w "${device}" && ${force} -eq 0 ]]; then
            error ${BASH_SOURCE[0]} ${LINENO} "Device '${device}' is not writable by the current user, please chown the device" 120
        elif [[ ! -w "${device}" && ${force} -eq 1 ]]; then
            echo "Device '${device}' is not writable by the current user, please chown the device. Forcing..."
        fi
    done
}

# (1: default for auto-select; *: list items)
function select_index_from_list () {
    local default_choice=0
    [[ ! -z $1 || $1 -eq -1 ]] && default_choice=$1
    [[ ! $1 =~ ^[0-9]+$ ]] \
            && error ${BASH_SOURCE[0]} ${LINENO} "Default index is invalid!"                90
    [[ ${auto_select} -eq 1 ]] \
            && echo "Selecting [${list[0]}]" && return ${default_choice}
    shift
    local list=($*)
    echo "$(declare -p "list" 2>/dev/null)"
    eval "$(declare -p "list" 2>/dev/null)"
    [[ ${#list} -eq 0 ]] \
            && error ${BASH_SOURCE[0]} ${LINENO} "No values provided!"                      91
    IFS=',' echo "items: (${list[@]})"
    for ((i = 0; i <= ${#list}; i++)); do
        local item="${list[i]}"
        printf "%0.2i: ${item}\n" $i
    done

    read -p "Choice? " selected_index

    [[ ! ${selected_index} =~ ^[0-9]+$ ]] \
            && error ${BASH_SOURCE[0]} ${LINENO} "Selected choice is not a valid number"    92
    [[ ${selected_index} -lt 0 || ${selected_index} -gt ${#list} ]] \
            && error ${BASH_SOURCE[0]} ${LINENO} "Selected choice is not a valid index"     93
    selected_item_index=${selected_index}
}

# (1: container command; 2: container command arguments)
function run_container () {
    local container_cmd=$1
    shift
    local container_args="$*"
    
    local device_args=""
    for dev in $(ls /dev/{video,media}* 2>/dev/null); do
        device_args="${device_args} --device=${dev}"
    done

    if [[ -z "${device_args}" && ${force} -eq 0 ]]; then
        echo "No video devices found. Run with -f to force run"
        exit 3
    fi

    __rm="--rm"
    [[ ${persist} -ne 0 ]] && __rm=""

    docker run -it ${__rm} \
        --privileged \
        \
        --device=/dev/bus/usb:/dev/bus/usb  \
        ${device_args}                      \
        \
        -p 1935:1935                        \
        -p 8000:8000                        \
        -p 8001:8001                        \
        -p 8554:8554                        \
        -p 8888:8888                        \
        -p 8889:8889                        \
        \
        doorbellian:${image_tag} ${container_cmd} ${container_args}
}

# (1: container command; 2: container command arguments)
function exec_container () {
    local container_cmd=$1
    local container_args=$2
    local container_id="$(docker ps -a --filter \"ancestor=doorbellian:${image_tag}\" --format '{{.ID}}')"

    [[ ! ${container_id} ]] && caller && echo "[ERROR]: Could not find an existing container..." && exit 10

    docker start ${container_id} >/dev/null
    docker exec -it ${container_id} ${container_cmd} ${container_args}
}

# ================================================================================================
#                                              FLAGS
add_flag "d" "debug" "enable debug mode (prints extra info)" 0
function flag_name_debug () {
    debug_mode=1
    debug "Enabling Debug Mode"
}

add_flag "f" "force" "run even if no camera devices are found" 1
function flag_name_force () {
    debug "forcing..."
    force=1
}

add_flag "p" "persistent" "container should persist after use" 1
function flag_name_persistent () {
    persist=1
    debug "Container will persist after use."
}

add_flag "a" "attach" "attach to existing persistent container if one exists" 2
function flag_name_attach () {
    attach=1
    if [[ -z "${container_id}" ]]; then
        local container_ids=($(docker ps -a --filter "ancestor=doorbellian:${image_tag}" --format '{{.ID}}' 2>/dev/null))
        if [[ ${#container_ids} -eq 0 ]]; then
            created_container=1
            debug "Creating container..."
            container_id="$(docker ps -a --filter "ancestor=doorbellian:${image_tag}" --format '{{.ID}}' 2>/dev/null)"
        elif [[ ${#container_ids} -eq 1 ]]; then
            container_id="$container_ids"
        else
            select_index_from_list 0 ${container_ids[@]}
            container_id="${container_ids[selected_item_index]}"
        fi
    fi
    debug "Attaching to container [${container_id:0:8}]..."
}

# add_flag "u" "update" "updates a container by copying the contents of 'deps/' into a currently running container before executing the target ; implicitly uses the -a flag" 2
function flag_name_update () {
    flag_a
    local container_ids=
    return
}

add_flag "-" "auto" "automatically selects an existing container to use (the first one found) or creates a new container" 1
function flag_name_auto () {
    auto_select=1
}

add_flag "-" "tag" "sets the docker tag for the selected target" 2
function flag_name_tag () {
    image_tag="${arguments[0]}"
    debug "using tag '${image_tag}'"
    arr_pop arguments 0
}

add_flag "-" "jobs" "sets the number of jobs/threads to use" 1
function flag_name_jobs () {
    [[ ! ${JOBS} =~ ^[0-9]+$ ]] && caller && echo "[ERROR]: JOBS value '${JOBS}' is not a valid number!" && exit 15
    JOBS=${arguments[0]}
    arr_pop arguments 0
    debug "Using -j${JOBS}"
}

add_flag "-" "dockerfile" "sets the dockerfile to use" 2 "dockerfile" "the dockerfile to use"
function flag_name_dockerfile () {
    dockerfile="${arguments[0]}"
    arr_pop arguments 0
    debug "using dockerfile '${dockerfile}'"
}

add_flag "-" "container" "the id for the container that should be used" 1 "container_id" "the id of the docker container that should be used"
function flag_name_container () {
    container_id="${arguments[0]}"
    debug "Using container [${container_id}]"
}

add_flag "-" "tina" "a shorthand flag for tina-based doorbellian development ; default is linux6.4 + busybox" 1
function flag_name_tina () {
    dockerfile="Dockerfile.tina"
    image_tag="tina"
    extra_args+=("--build-arg 'SIGN_NAME=${SIGN_NAME}'")
    extra_args+=("--build-arg 'SIGN_EMAIL=${SIGN_EMAIL}'")
    debug "using dockerfile:    '${dockerfile}'"
    debug "using tag:           '${image_tag}'"
    debug "using signing name:  '${SIGN_NAME}'"
    debug "using signing email: '${SIGN_EMAIL}'"
}

add_flag "-" "arg" "additional arguments to pass to the target ; can be used multiple times" 1
function flag_name_arg () {
    extra_args+=(${arguments[0]})
    arr_pop arguments 0
}

add_flag "-" "no-cache" "Only functions during the build target, builds a docker image without using a cache" 2
function flag_name_no_cache () {
    extra_args+=("--no-cache")
}

# ================================================================================================
#                                             TARGETS
add_target "usb" "list found camera devices"
function target_usb () {
    usb_init

    echo ==============================================================
    echo -e "${cam_output}"
    echo ==============================================================
    echo -e "${lsusb_output}"
    echo ==============================================================

    # Print the extracted IDs
    echo "Extracted Device IDs:    ${ids//|/,}"
    echo "Extracted USB Bus IDs:   ${bus_ids}"
    echo "Extracted USB Addresses: ${bus_addrs}"
    echo "Extracted USB List:      ${usb_list[@]}"

    echo ==============================================================

    validate_usb_devices
    [[ ${force} -eq 0 ]] && echo "found USB devices are all valid!"
}

add_target "clean" "clean out the related containers and images, and dangling images"
function target_clean () {
    debug "cleaning..."
    docker ps -a --filter "status=created" --format "{{.ID}}" | xargs -r docker rm
    docker ps -a --filter "status=exited" --format "{{.ID}}" | xargs -r docker rm
    if [[ -n "$(docker images -q doorbellian:${image_tag} 2> /dev/null)" ]]; then
        [[ ! -z "${image_tag}" ]] && docker image rm --force doorbellian:${image_tag} || docker image rm --force doorbellian
    fi
    docker images -f "dangling=true" --format "{{.ID}}" | xargs -r docker rmi
    debug "cleaned."
}

add_target "build" "build the docker image"
function target_build () {
    local _run="docker build --build-arg JOBS=${JOBS} -f \"${dockerfile}\" -t doorbellian:${image_tag} ${extra_args[*]} ."
    debug "${_run}"
    eval "${_run}"
    return $?
}

add_target "extract" "extract logs from the constructed image"
function target_extract () {
    if [[ -n "$(docker images -q doorbellian:${image_tag} 2> /dev/null)" ]]; then
        local extracts=(${arguments[@]})
        local container_ids=($(docker ps -a --filter "ancestor=doorbellian:${image_tag}" --format '{{.ID}}' 2>/dev/null))
        local container_id=""
        local created=0

        [[ ${#container_ids[@]} -gt 1 ]] && IFS=',' echo "[ERROR]: too many available containers: (${container_id[*]})" && exit 20
        [[ ${#container_ids[@]} -eq 0 ]] && created=1 && container_id="$(docker create doorbellian:${image_tag})" || container_id=${container_ids[0]}

        for extracted in "${extracts[@]}"; do
            IFS=';' read -ra extracted_parts <<< "${extracted}"
            local _from="${extracted_parts[0]}"
            local _to="${extracted_parts[0]}"
            # IFS='#' echo "(${extracted_parts[@]})"
            [[ ${#extracted_parts} -gt 1 ]] && _to="${extracted_parts[1]}"
            echo "Extracted ${container_id:0:8}:'${_from}' to 'tmp/${_to}'"
            docker cp "${container_id}:${_from}" "tmp/${_to}" 2>&1 >/dev/null
        done
        [[ ${created} -eq 1 ]] && docker rm -v ${container_id} 2>&1 >/dev/null
    else
        echo "No valid images found to extract from! Please run '${SCRIPT_NAME} --tag ${image_tag} --dockerfile ${dockerfile} build'"
    fi
}

add_target "bae" "build target followed by extract target"
function target_bae () {
    target_build
    target_extract
}

add_target "run" "run docker container with default command"
function target_run () {
    usb_init
    validate_usb_devices
    local _target="run_container"
    local container_ids=($(docker ps -a --filter "ancestor=doorbellian:${image_tag}" --format '{{.ID}}' 2>/dev/null))
    [[ ${attach} -ne 0 && ${#container_ids} -eq 1 ]] && _target="exec_container"
    eval "${_target} \"./doorbellian-qemu.sh\" ${usb_list[@]}"
}

add_target "bash" "run docker container with /bin/bash"
function target_bash () {
    local _target="run_container"
    local container_ids=($(docker ps -a --filter "ancestor=doorbellian:${image_tag}" --format '{{.ID}}' 2>/dev/null))
    [[ ${attach} -ne 0 && ${#container_ids} -eq 1 ]] && _target="exec_container"
    eval "${_target} '/bin/bash'"
}

add_target "kill" "kills and deletes related running containers"
function target_kill () {
    local container_ids=($(docker ps -a --filter "ancestor=doorbellian:${image_tag}" --format '{{.ID}}' 2>/dev/null))
    [[ ${#container_ids[@]} -eq 0 ]] && echo "No containers to kill." && return

    for container_id in "${container_ids[@]}"; do
        docker kill "$container_id" 2>&1 >/dev/null
        [[ $? -eq 0 ]] && echo "Container $container_id killed."

        docker rm "$container_id"
        [[ $? -eq 0 ]] && echo "Container $container_id deleted."
    done
}

add_target "bar" "build target followed by run target"
function target_bar () {
    target_build && target_run && return
    echo "[Error]: Build failed, exiting..."
    exit 100
}

add_target "debug" "use buildg to step through the dockerfile"
function target_debug () {
    buildg debug --file ${dockerfile} .
    exit 0
}

# ================================================================================================
#                                               MAIN
function main () {
    validate_dependencies
    init
    validate_flags
    execute_flags
    validate_target
    cleanup
}

main

